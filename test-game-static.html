<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Highway - Static Test View</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .description {
            color: #666;
            margin-bottom: 20px;
            text-align: center;
            max-width: 800px;
        }
        #gameContainer {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        canvas {
            border: 2px solid #333;
            display: block;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .info h3 {
            margin-top: 0;
            color: #333;
        }
        .info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .info li {
            margin: 5px 0;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Mountain Highway - Static Test View</h1>
    <p class="description">
        Static visualization of the game course with all debug features enabled.
        This view shows the complete layout without animation, making it easier to understand
        the course structure, island placement, and bridge zones.
    </p>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div class="info">
        <h3>Debug Features Enabled:</h3>
        <ul>
            <li><strong>Grid Lines:</strong> Blue grid showing row/column coordinates</li>
            <li><strong>Island Numbers:</strong> Course-visit order (0 = start island)</li>
            <li><strong>Bridge Zones:</strong> White areas with green outlines showing safe bridge lengths</li>
            <li><strong>Course Path:</strong> Yellow dots (junctions) and lines (spans)</li>
            <li><strong>Car:</strong> Positioned at start location</li>
        </ul>
    </div>

    <!-- Load all game scripts -->
    <script src="js/config.js"></script>
    <script src="js/renderer.js"></script>
    <script src="js/course.js"></script>
    <script src="js/validation.js"></script>
    <script src="js/level.js"></script>
    <script src="js/debug.js"></script>

    <script>
        // Create static test visualization
        class StaticGameView {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');

                // Load the level first
                this.level = createExampleLevel();
                this.course = this.level.course;
                this.islands = this.level.islands;

                // Calculate viewport bounds and canvas size
                const {viewport, canvasWidth, canvasHeight} = this.createViewportAndCanvasSize();

                // Set canvas dimensions
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;

                this.viewport = viewport;

                // Car state (at start)
                this.carRow = 1;
                this.carCol = 1;
                this.carDirection = 'column';

                // Create renderer and wait for sprites to load before rendering
                this.renderer = new Renderer(this.canvas, this.viewport, () => {
                    // Render once sprites are loaded
                    this.render();
                });
                this.debug = new DebugRenderer(this.renderer);
            }

            createViewportAndCanvasSize() {
                const blockSize = GameConfig.grid.blockSize;

                // Calculate bounds from islands to show full course
                let minRow = Infinity;
                let maxRow = -Infinity;
                let minCol = Infinity;
                let maxCol = -Infinity;

                this.islands.forEach(([row, col, width, height]) => {
                    minRow = Math.min(minRow, row);
                    maxRow = Math.max(maxRow, row + height);
                    minCol = Math.min(minCol, col);
                    maxCol = Math.max(maxCol, col + width);
                });

                // Add 1 unit margin on all sides
                minRow -= 1;
                maxRow += 1;
                minCol -= 1;
                maxCol += 1;

                // Calculate canvas size needed to fit this viewport
                const rowSpan = maxRow - minRow;
                const colSpan = maxCol - minCol;
                const canvasWidth = Math.ceil(colSpan * blockSize);
                const canvasHeight = Math.ceil(rowSpan * blockSize);

                const viewport = new Viewport(minRow, maxRow, minCol, maxCol, blockSize, canvasWidth, canvasHeight);

                return {viewport, canvasWidth, canvasHeight};
            }

            render() {
                this.renderer.clear();

                const blockSize = this.viewport.blockSize;

                // Apply viewport transform
                this.renderer.ctx.save();
                const offset = this.viewport.getOffset();
                this.renderer.ctx.translate(offset.x, offset.y);

                // Draw debug grid
                this.debug.drawGrid(this.viewport.minRow, this.viewport.maxRow,
                                  this.viewport.minCol, this.viewport.maxCol, blockSize);

                const wallHeight = GameConfig.island.wallHeight;

                // Sort islands by distance from camera (row + col, descending) for proper back-to-front rendering
                // Higher sum = farther from camera (rendered first)
                // Lower sum = closer to camera (rendered last, overlays others)
                const sortedIndices = this.islands
                    .map((island, idx) => ({island, idx}))
                    .sort((a, b) => (b.island[0] + b.island[1]) - (a.island[0] + a.island[1]))
                    .map(item => item.idx);

                // Render each island
                sortedIndices.forEach(islandIndex => {
                    const [row, col, width, height] = this.islands[islandIndex];

                    // Draw island colors
                    const corners = this.renderer.drawIslandColors(row, col, width, height, wallHeight, blockSize);

                    // Draw road
                    const roadSegments = this.course.getRoadSegmentsForIsland(islandIndex, this.islands);
                    this.renderer.drawIslandRoadFromSpans(row, col, width, height, roadSegments, blockSize);

                    // Draw outlines
                    this.renderer.drawIslandOutlines(corners);
                });

                // Draw bridge zones
                this.debug.drawBridgeZones(this.course, this.islands, blockSize);

                // Draw course overlay (yellow dots and lines)
                this.drawCourseOverlay();

                // Draw car at start position
                this.renderer.drawCar(this.carRow, this.carCol, this.carDirection, blockSize);

                // Draw island numbers
                this.islands.forEach(([row, col, width, height], islandNum) => {
                    this.debug.drawIslandNumber(row, col, width, height, islandNum, blockSize);
                });

                this.renderer.ctx.restore();
            }

            drawCourseOverlay() {
                const ctx = this.renderer.ctx;
                const blockSize = this.viewport.blockSize;
                const spanDetails = this.course.getSpanDetails();

                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'yellow';

                // Draw start position
                const startScreen = this.renderer.gameToScreen(this.course.startRow, this.course.startCol, 0);
                ctx.beginPath();
                ctx.arc(startScreen.x * blockSize, startScreen.y * blockSize, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw each span as a line
                let currentRow = this.course.startRow;
                let currentCol = this.course.startCol;

                spanDetails.forEach((span, idx) => {
                    // Draw line from current position to junction
                    const startScreen = this.renderer.gameToScreen(currentRow, currentCol, 0);
                    const endScreen = this.renderer.gameToScreen(span.endRow, span.endCol, 0);

                    ctx.beginPath();
                    ctx.moveTo(startScreen.x * blockSize, startScreen.y * blockSize);
                    ctx.lineTo(endScreen.x * blockSize, endScreen.y * blockSize);
                    ctx.stroke();

                    // Draw junction point
                    ctx.beginPath();
                    ctx.arc(endScreen.x * blockSize, endScreen.y * blockSize, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Update current position
                    currentRow = span.endRow;
                    currentCol = span.endCol;
                });
            }
        }

        // Create the static view when page loads
        window.addEventListener('load', () => {
            new StaticGameView();
        });
    </script>
</body>
</html>
