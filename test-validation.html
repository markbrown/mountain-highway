<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Validation Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
        }
        h1 { color: #333; }
        h2 { color: #666; margin-top: 30px; }
        .test-case {
            background: #f5f5f5;
            border-left: 4px solid #999;
            padding: 15px;
            margin: 15px 0;
        }
        .test-case.pass {
            border-left-color: #4CAF50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background: #fef1f0;
        }
        .test-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
        }
        .test-description {
            color: #666;
            font-style: italic;
            margin-bottom: 10px;
        }
        .console-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .visualization {
            margin-top: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background: white;
            display: flex;
            justify-content: center;
        }
        .visualization canvas {
            border: 1px solid #ccc;
        }
        .course-details {
            margin-top: 15px;
            font-size: 0.9em;
        }
        .course-details h4 {
            margin: 10px 0 5px 0;
            color: #444;
            font-size: 1em;
        }
        .course-details table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }
        .course-details th {
            background: #e0e0e0;
            padding: 5px 8px;
            text-align: left;
            border: 1px solid #ccc;
        }
        .course-details td {
            padding: 5px 8px;
            border: 1px solid #ddd;
        }
        .course-details tr:nth-child(even) {
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <h1>Course Validation Test Suite</h1>
    <p>Testing the course validation system with various valid and invalid configurations.</p>

    <div id="test-results"></div>

    <script src="js/config.js"></script>
    <script src="js/renderer.js"></script>
    <script src="js/course.js"></script>
    <script src="js/debug.js"></script>
    <script src="js/validation.js"></script>
    <script>
        // Static course visualizer using Viewport
        class CourseVisualizer {
            static render(course, islands) {
                // Calculate bounds - all island tops plus 1 unit margin
                const bounds = this.calculateBounds(islands);

                // Create viewport for this region
                const viewport = new Viewport(
                    bounds.minRow, bounds.maxRow,
                    bounds.minCol, bounds.maxCol
                );

                // Create canvas with viewport
                const canvas = document.createElement('canvas');
                const renderer = new Renderer(canvas, viewport);
                const debug = new DebugRenderer(renderer);

                // Clear background
                renderer.clear();

                // Apply viewport transform
                const ctx = renderer.ctx;
                ctx.save();
                const offset = viewport.getOffset();
                ctx.translate(offset.x, offset.y);

                const blockSize = viewport.blockSize;
                const wallHeight = GameConfig.island.wallHeight;

                // Draw debug grid starting from (0,0) even though viewport may have margin
                const gridMinRow = Math.max(0, bounds.minRow);
                const gridMinCol = Math.max(0, bounds.minCol);
                debug.drawGrid(gridMinRow, bounds.maxRow, gridMinCol, bounds.maxCol, blockSize);

                // Render islands (back to front)
                // Sort by distance from camera (row + col sum, higher = farther)
                const sortedIslands = [...islands].sort((a, b) => {
                    const distA = a[0] + a[1];  // row + col
                    const distB = b[0] + b[1];
                    return distB - distA;  // Render farthest first
                });

                // Get island indices for course-order
                sortedIslands.forEach((island, visualIndex) => {
                    const [row, col, width, height] = island;

                    // Find the course-order index for this island
                    const islandIndex = islands.findIndex(isl =>
                        isl[0] === row && isl[1] === col && isl[2] === width && isl[3] === height
                    );

                    // Draw island
                    const corners = renderer.drawIslandColors(row, col, width, height, wallHeight, blockSize);

                    // Draw road using new method
                    const roadSegments = course.getRoadSegmentsForIsland(islandIndex, islands);
                    renderer.drawIslandRoadFromSpans(row, col, width, height, roadSegments, blockSize);

                    renderer.drawIslandOutlines(corners);
                });

                // Draw course overlay (junctions and spans in yellow)
                this.drawCourseOverlay(renderer, course, blockSize);

                ctx.restore();
                return canvas;
            }

            static drawCourseOverlay(renderer, course, blockSize) {
                const ctx = renderer.ctx;
                const spanDetails = course.getSpanDetails();

                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'yellow';

                // Draw start position
                const startScreen = renderer.gameToScreen(course.startRow, course.startCol, 0);
                ctx.beginPath();
                ctx.arc(startScreen.x * blockSize, startScreen.y * blockSize, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw each span as a line
                let currentRow = course.startRow;
                let currentCol = course.startCol;

                spanDetails.forEach((span, idx) => {
                    // Draw line from current position to junction
                    const startScreen = renderer.gameToScreen(currentRow, currentCol, 0);
                    const endScreen = renderer.gameToScreen(span.endRow, span.endCol, 0);

                    ctx.beginPath();
                    ctx.moveTo(startScreen.x * blockSize, startScreen.y * blockSize);
                    ctx.lineTo(endScreen.x * blockSize, endScreen.y * blockSize);
                    ctx.stroke();

                    // Draw junction point
                    ctx.beginPath();
                    ctx.arc(endScreen.x * blockSize, endScreen.y * blockSize, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Update current position
                    currentRow = span.endRow;
                    currentCol = span.endCol;
                });
            }

            static calculateBounds(islands) {
                let minRow = Infinity, maxRow = -Infinity;
                let minCol = Infinity, maxCol = -Infinity;

                islands.forEach(island => {
                    const [row, col, width, height] = island;
                    minRow = Math.min(minRow, row);
                    maxRow = Math.max(maxRow, row + height);
                    minCol = Math.min(minCol, col);
                    maxCol = Math.max(maxCol, col + width);
                });

                // Add 1 unit margin (viewport can go below 0 for margin)
                return {
                    minRow: minRow - 1,
                    maxRow: maxRow + 1,
                    minCol: minCol - 1,
                    maxCol: maxCol + 1
                };
            }
        }

        // Helper to render course and island details
        class DetailsRenderer {
            static renderCourseDetails(course) {
                const spanDetails = course.getSpanDetails();

                let html = '<h4>Course Configuration</h4>';
                html += '<table>';
                html += '<tr><th>Span</th><th>Start</th><th>End</th><th>Length</th><th>Direction</th><th>Junction Type</th></tr>';

                spanDetails.forEach((span, idx) => {
                    const junctionType = span.junction || 'none (end)';
                    html += `<tr>`;
                    html += `<td>${idx}</td>`;
                    html += `<td>(${span.startRow}, ${span.startCol})</td>`;
                    html += `<td>(${span.endRow}, ${span.endCol})</td>`;
                    html += `<td>${span.length}</td>`;
                    html += `<td>${span.direction}</td>`;
                    html += `<td>${junctionType}</td>`;
                    html += `</tr>`;
                });

                html += '</table>';
                return html;
            }

            static renderIslandDetails(islands) {
                let html = '<h4>Island Configuration</h4>';
                html += '<table>';
                html += '<tr><th>#</th><th>Bridges Crossed</th><th>Position</th><th>Width</th><th>Height</th><th>Bounds</th></tr>';

                islands.forEach((island, idx) => {
                    const [row, col, width, height] = island;
                    html += `<tr>`;
                    html += `<td>${idx}</td>`;
                    html += `<td>${idx}</td>`;
                    html += `<td>(${row}, ${col})</td>`;
                    html += `<td>${width}</td>`;
                    html += `<td>${height}</td>`;
                    html += `<td>(${row}, ${col}) to (${row + height}, ${col + width})</td>`;
                    html += `</tr>`;
                });

                html += '</table>';
                return html;
            }
        }

        // Test runner
        class TestRunner {
            constructor() {
                this.results = [];
            }

            test(name, description, courseFn, islandsFn, shouldPass) {
                const course = courseFn();
                const islands = islandsFn();

                const result = CourseValidator.validate(course, islands);

                const passed = result.valid === shouldPass;

                this.results.push({
                    name,
                    description,
                    passed,
                    shouldPass,
                    result,
                    course,
                    islands
                });

                return passed;
            }

            renderResults() {
                const container = document.getElementById('test-results');

                this.results.forEach(test => {
                    const div = document.createElement('div');
                    div.className = `test-case ${test.passed ? 'pass' : 'fail'}`;

                    const name = document.createElement('div');
                    name.className = 'test-name';
                    name.textContent = `${test.passed ? '✅' : '❌'} ${test.name}`;
                    div.appendChild(name);

                    const desc = document.createElement('div');
                    desc.className = 'test-description';
                    desc.textContent = test.description;
                    div.appendChild(desc);

                    // Add visualization
                    const vizDiv = document.createElement('div');
                    vizDiv.className = 'visualization';
                    try {
                        const canvas = CourseVisualizer.render(test.course, test.islands);
                        vizDiv.appendChild(canvas);
                    } catch (e) {
                        vizDiv.innerHTML = `<em>Unable to render: ${e.message}</em>`;
                    }
                    div.appendChild(vizDiv);

                    // Add course and island details
                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'course-details';
                    detailsDiv.innerHTML = DetailsRenderer.renderCourseDetails(test.course);
                    detailsDiv.innerHTML += DetailsRenderer.renderIslandDetails(test.islands);
                    div.appendChild(detailsDiv);

                    const output = document.createElement('div');
                    output.className = 'console-output';

                    if (test.result.valid) {
                        output.innerHTML = '<span class="success">✅ All checks passed!</span>';
                    } else {
                        output.innerHTML = `<span class="error">❌ Found ${test.result.errors.length} error(s):</span>\n`;
                        test.result.errors.forEach(error => {
                            output.innerHTML += `  - ${error.toString()}\n`;
                        });
                    }

                    div.appendChild(output);
                    container.appendChild(div);
                });

                // Summary
                const passed = this.results.filter(r => r.passed).length;
                const total = this.results.length;

                const summary = document.createElement('h2');
                summary.innerHTML = `Test Summary: ${passed}/${total} tests passed`;
                summary.style.color = passed === total ? '#4CAF50' : '#f44336';
                container.insertBefore(summary, container.firstChild);
            }
        }

        // Run tests
        const runner = new TestRunner();

        // Test 1: Valid configuration (current game)
        runner.test(
            'Test 1: Valid Course',
            'The current game configuration should pass all validation checks',
            () => createExampleCourse(),
            () => [
                [0, 0, 2, 2],   // Island 0: Start (0 bridges crossed)
                [0, 4, 2, 2],   // Island 1: After bridge 0
                [5, 4, 2, 2],   // Island 2: After bridge 1
                [8, 4, 4, 2],   // Island 3: After bridge 2 (has 2 junctions)
                [12, 6, 2, 2],  // Island 4: After bridge 3 (final destination)
            ],
            true
        );

        // Test 2: Island too small (width)
        runner.test(
            'Test 2: Island Too Narrow',
            'Island with width < 2 should fail validation',
            () => createExampleCourse(),
            () => [
                [8, 4, 4, 2],
                [5, 4, 2, 2],
                [0, 4, 1, 2], // Width = 1 (too small)
                [0, 0, 2, 2],
            ],
            false
        );

        // Test 3: Island too small (height)
        runner.test(
            'Test 3: Island Too Short',
            'Island with height < 2 should fail validation',
            () => createExampleCourse(),
            () => [
                [8, 4, 4, 2],
                [5, 4, 2, 1], // Height = 1 (too small)
                [0, 4, 2, 2],
                [0, 0, 2, 2],
            ],
            false
        );

        // Test 4: Junction on edge
        runner.test(
            'Test 4: Junction On Edge',
            'Junction exactly on island edge should fail (must be 1+ units from edge)',
            () => {
                const course = new Course();
                course.addSpan(3, Direction.COLUMN); // Length 3: junction at (1,4) - exactly on island edge
                course.addSpan(5, Direction.ROW);
                return course;
            },
            () => [
                [0, 4, 2, 7], // Island at col 4, junction at col 4 is exactly on edge
                [0, 0, 2, 2],
            ],
            false
        );

        // Test 5: Gap too small
        runner.test(
            'Test 5: Gap Too Small',
            'Gap between islands < 1 unit should fail',
            () => {
                const course = new Course();
                course.addSpan(2, Direction.COLUMN); // Length 2: junction at (1,3)
                return course;
            },
            () => [
                [0, 0, 2, 2],  // Island 0 (start): cols [0, 2)
                [0, 2, 2, 2],  // Island 1 (after bridge): cols [2, 4) - gap of 0 (islands touching)
            ],
            false
        );

        // Test 6: Bridge tolerance too small
        runner.test(
            'Test 6: Bridge Tolerance Too Small',
            'Difference between min and max bridge size < 1 unit should fail',
            () => {
                const course = new Course();
                course.addSpan(4, Direction.COLUMN);
                return course;
            },
            () => [
                [0, 4, 1.5, 2], // Small island = small tolerance
                [0, 0, 2, 2],
            ],
            false
        );

        // Test 7: Start position not on island
        runner.test(
            'Test 7: Start Position Off Island',
            'Start position (1,1) not on any island should fail',
            () => createExampleCourse(),
            () => [
                [8, 4, 4, 2],
                [5, 4, 2, 2],
                [0, 4, 2, 2],
                [3, 3, 2, 2], // Doesn't cover (1,1)
            ],
            false
        );

        // Test 8: Junction not on any island
        runner.test(
            'Test 8: Junction In Gap',
            'Junction not on any island should fail',
            () => {
                const course = new Course();
                course.addSpan(10, Direction.COLUMN); // Ends at (1,11) - in gap
                return course;
            },
            () => [
                [0, 15, 2, 2], // Far away
                [0, 0, 2, 2],
            ],
            false
        );

        // Test 9: Valid minimal configuration
        runner.test(
            'Test 9: Valid Minimal Course',
            'Minimal valid configuration: 2x2 islands with 1 unit gap',
            () => {
                const course = new Course();
                course.addSpan(4, Direction.COLUMN);
                return course;
            },
            () => [
                [0, 5, 2, 2], // Gap of exactly 1 unit
                [0, 0, 2, 2],
            ],
            true
        );

        // Test 10: Valid larger islands
        runner.test(
            'Test 10: Valid Large Islands',
            'Larger islands with bigger gaps should pass',
            () => {
                const course = new Course();
                course.addSpan(8, Direction.COLUMN);
                return course;
            },
            () => [
                [0, 10, 5, 5], // Large island, gap of 2 units
                [0, 0, 5, 5],
            ],
            true
        );

        // Render all results
        runner.renderResults();

        // Log to console as well
        console.log(`\n=== Test Suite Complete ===`);
        console.log(`Passed: ${runner.results.filter(r => r.passed).length}/${runner.results.length}`);
    </script>
</body>
</html>
